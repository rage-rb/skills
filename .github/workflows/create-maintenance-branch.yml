name: Create maintenance branch

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

jobs:
  ensure-branch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Create vMAJOR.MINOR branch if missing
        env:
          TAG_NAME: ${{ github.ref_name }} # e.g. v1.22.0
        run: |
          set -euo pipefail

          # Validate and parse tag vX.Y.Z
          if [[ ! "$TAG_NAME" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "Tag '$TAG_NAME' doesn't match vMAJOR.MINOR.PATCH; skipping."
            exit 0
          fi

          major="${BASH_REMATCH[1]}"
          minor="${BASH_REMATCH[2]}"
          branch="release/${major}.${minor}"
          tag_ref="refs/tags/${TAG_NAME}"

          echo "Tag:    $TAG_NAME"
          echo "Branch: $branch"

          # Ensure we have an up-to-date view of remote branches
          git fetch origin "+refs/heads/*:refs/remotes/origin/*" --prune

          if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
            echo "Remote branch '$branch' already exists. Nothing to do."
            exit 0
          fi

          # Resolve the commit the tag points to (works for lightweight or annotated tags)
          commit="$(git rev-list -n 1 "$tag_ref")"
          echo "Creating '$branch' at commit $commit (from $TAG_NAME)"

          # Create and push branch to origin
          git branch "$branch" "$commit"
          git push origin "refs/heads/$branch"

          echo "Done."
